From 71a09b4c2e1d075fce9c0ae09e044dbde36bffba Mon Sep 17 00:00:00 2001
Message-ID: <71a09b4c2e1d075fce9c0ae09e044dbde36bffba.1765628489.git.lorenzo@kernel.org>
In-Reply-To: <533ca4c0e73e768cd82fe76fb30f814043f1f718.1765628489.git.lorenzo@kernel.org>
References: <533ca4c0e73e768cd82fe76fb30f814043f1f718.1765628489.git.lorenzo@kernel.org>
From: Lorenzo Bianconi <lorenzo@kernel.org>
Date: Sat, 13 Dec 2025 09:45:09 +0100
Subject: [nf-next 11/11] net: airoha: Add ethtool priv_flags callbacks

Introduce ethtool priv_flags callbacks in order to allow the user to
select if the configured device will be used as hw lan or wan.

Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
---
 drivers/net/ethernet/airoha/airoha_eth.c | 66 ++++++++++++++++++++++--
 drivers/net/ethernet/airoha/airoha_eth.h | 31 +++++++++--
 2 files changed, 88 insertions(+), 9 deletions(-)

--- a/drivers/net/ethernet/airoha/airoha_eth.c
+++ b/drivers/net/ethernet/airoha/airoha_eth.c
@@ -1630,6 +1630,9 @@ static int airoha_dev_open(struct net_de
 	struct airoha_gdm_port *port = dev->port;
 	struct airoha_qdma *qdma = port->qdma;
 
+	if (port->id == AIROHA_GDM2_IDX && !(dev->flags & PRIV_FLAG_WAN))
+		return -EBUSY;
+
 #if defined(CONFIG_PCS_AIROHA)
 	if (airhoa_is_phy_external(port)) {
 		err = phylink_of_phy_connect(dev->phylink,
@@ -1729,11 +1732,16 @@ static int airhoha_enable_gdm2_loopback(
 	u32 val, pse_port, chan;
 	int src_port;
 
+	/* Disable GDM2 forwding during configuration */
+	airoha_set_gdm_port_fwd_cfg(eth, REG_GDM_FWD_CFG(AIROHA_GDM2_IDX),
+				    FE_PSE_PORT_DROP);
 	/* Forward the traffic to the proper GDM port */
 	pse_port = port->id == AIROHA_GDM3_IDX ? FE_PSE_PORT_GDM3
 					       : FE_PSE_PORT_GDM4;
-	airoha_set_gdm_port_fwd_cfg(eth, REG_GDM_FWD_CFG(2), pse_port);
-	airoha_fe_clear(eth, REG_GDM_FWD_CFG(2), GDM_STRIP_CRC_MASK);
+	airoha_set_gdm_port_fwd_cfg(eth, REG_GDM_FWD_CFG(AIROHA_GDM2_IDX),
+				    pse_port);
+	airoha_fe_clear(eth, REG_GDM_FWD_CFG(AIROHA_GDM2_IDX),
+			GDM_STRIP_CRC_MASK);
 
 	/* Enable GDM2 loopback */
 	airoha_fe_wr(eth, REG_GDM_TXCHN_EN(2), 0xffffffff);
@@ -1767,14 +1775,42 @@ static int airhoha_enable_gdm2_loopback(
 		      SP_CPORT_MASK(val),
 		      FE_PSE_PORT_CDM2 << __ffs(SP_CPORT_MASK(val)));
 
-	if (port->id != AIROHA_GDM3_IDX && airoha_is_7581(eth))
-		airoha_fe_rmw(eth, REG_SRC_PORT_FC_MAP6,
-			      FC_ID_OF_SRC_PORT24_MASK,
-			      FIELD_PREP(FC_ID_OF_SRC_PORT24_MASK, 2));
+	if (port->id == AIROHA_GDM4_IDX && airoha_is_7581(eth)) {
+		u32 mask = FC_ID_OF_SRC_PORT_MASK(dev->nbq);
+
+		airoha_fe_rmw(eth, REG_SRC_PORT_FC_MAP6, mask,
+			      AIROHA_GDM2_IDX << __ffs(mask));
+	}
 
 	return 0;
 }
 
+static void airhoha_disable_gdm2_loopback(struct airoha_gdm_dev *dev)
+{
+	struct airoha_gdm_port *port = dev->port;
+	struct airoha_eth *eth = port->qdma->eth;
+	u32 pse_port, len;
+
+	/* Disable GDM2 forwding during configuration */
+	airoha_set_gdm_port_fwd_cfg(eth, REG_GDM_FWD_CFG(AIROHA_GDM2_IDX),
+				    FE_PSE_PORT_DROP);
+	pse_port = airoha_ppe_is_enabled(eth, 1) ? FE_PSE_PORT_PPE2
+						 : FE_PSE_PORT_PPE1;
+	airoha_set_gdm_port_fwd_cfg(eth, REG_GDM_FWD_CFG(AIROHA_GDM2_IDX),
+				    pse_port);
+
+	len = ETH_HLEN + dev->dev->mtu + ETH_FCS_LEN;
+	airoha_fe_rmw(eth, REG_GDM_LEN_CFG(AIROHA_GDM2_IDX),
+		      GDM_LONG_LEN_MASK, FIELD_PREP(GDM_LONG_LEN_MASK, len));
+
+	airoha_fe_clear(eth, REG_GDM_LPBK_CFG(AIROHA_GDM2_IDX), LPBK_EN_MASK);
+	airoha_fe_rmw(eth, REG_FE_WAN_PORT, WAN0_MASK,
+		      FIELD_PREP(WAN0_MASK, AIROHA_GDM2_IDX));
+
+	if (port->id == AIROHA_GDM4_IDX && airoha_is_7581(eth))
+		airoha_fe_wr(eth, REG_SRC_PORT_FC_MAP6, FC_MAP6_DEF_VALUE);
+}
+
 static int airoha_dev_init(struct net_device *netdev)
 {
 	struct airoha_gdm_dev *dev = netdev_priv(netdev);
@@ -1787,18 +1823,23 @@ static int airoha_dev_init(struct net_de
 	airoha_set_macaddr(dev, netdev->dev_addr);
 
 	switch (port->id) {
-	case 3:
-	case 4:
-		/* If GDM2 is active we can't enable loopback */
-		if (!eth->ports[1]) {
+	case AIROHA_GDM3_IDX:
+	case AIROHA_GDM4_IDX:
+		if (!eth->ports[1] && !airhoa_get_wan_gdm_dev(eth)) {
 			int err;
 
 			err = airhoha_enable_gdm2_loopback(dev);
 			if (err)
 				return err;
+
+			dev->flags |= PRIV_FLAG_WAN;
 		}
 		fallthrough;
-	case 2:
+	case AIROHA_GDM2_IDX:
+		/* GDM2 is always used as wan */
+		if (port->id == AIROHA_GDM2_IDX)
+			dev->flags |= PRIV_FLAG_WAN;
+
 		if (airoha_ppe_is_enabled(eth, 1)) {
 			/* For PPE2 always use secondary cpu port. */
 			fe_cpu_port = FE_PSE_PORT_CDM2;
@@ -2083,6 +2124,62 @@ error:
 	return NETDEV_TX_OK;
 }
 
+struct airoha_ethool_priv_flags {
+	char name[ETH_GSTRING_LEN];
+	int (*handler)(struct net_device *netdev, u32 flags);
+};
+
+static int airoha_dev_set_wan_flag(struct net_device *netdev, u32 flags)
+{
+	struct airoha_gdm_dev *dev = netdev_priv(netdev);
+	struct airoha_gdm_port *port = dev->port;
+	struct airoha_eth *eth = port->qdma->eth;
+
+	if (!((dev->flags ^ flags) & PRIV_FLAG_WAN))
+		return 0;
+
+	if (flags & PRIV_FLAG_WAN) {
+		struct airoha_gdm_dev *wan_dev;
+
+		/* Verify the wan device is not already configured */
+		wan_dev = airhoa_get_wan_gdm_dev(eth);
+		if (wan_dev && wan_dev != dev)
+			return -EBUSY;
+
+		switch (port->id) {
+		case AIROHA_GDM3_IDX:
+		case AIROHA_GDM4_IDX: {
+			int err;
+
+			err = airhoha_enable_gdm2_loopback(dev);
+			if (err)
+				return err;
+			break;
+		}
+		case AIROHA_GDM2_IDX:
+			airhoha_disable_gdm2_loopback(dev);
+			break;
+		default:
+			return -EOPNOTSUPP;
+		}
+
+		dev->flags |= PRIV_FLAG_WAN;
+		airoha_set_macaddr(dev, netdev->dev_addr);
+	} else {
+		if (port->id == AIROHA_GDM2_IDX && netif_running(netdev))
+			return -EBUSY;
+
+		dev->flags &= ~PRIV_FLAG_WAN;
+	}
+
+	return 0;
+}
+
+static const struct airoha_ethool_priv_flags airoha_eth_priv_flags[] = {
+	{ "wan", airoha_dev_set_wan_flag },
+};
+#define AIROHA_PRIV_FLAGS_STR_LEN	ARRAY_SIZE(airoha_eth_priv_flags)
+
 static void airoha_ethtool_get_drvinfo(struct net_device *netdev,
 				       struct ethtool_drvinfo *info)
 {
@@ -2092,6 +2189,7 @@ static void airoha_ethtool_get_drvinfo(s
 
 	strscpy(info->driver, eth->dev->driver->name, sizeof(info->driver));
 	strscpy(info->bus_info, dev_name(eth->dev), sizeof(info->bus_info));
+	info->n_priv_flags = AIROHA_PRIV_FLAGS_STR_LEN;
 }
 
 static void airoha_ethtool_get_mac_stats(struct net_device *netdev,
@@ -2156,6 +2254,56 @@ airoha_ethtool_get_rmon_stats(struct net
 	} while (u64_stats_fetch_retry(&port->stats.syncp, start));
 }
 
+static int airoha_ethtool_set_priv_flags(struct net_device *netdev, u32 flags)
+{
+	int i;
+
+	for (i = 0; i < AIROHA_PRIV_FLAGS_STR_LEN; i++) {
+		int err;
+
+		if (!airoha_eth_priv_flags[i].handler)
+			continue;
+
+		err = airoha_eth_priv_flags[i].handler(netdev, flags);
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
+
+static u32 airoha_ethtool_get_priv_flags(struct net_device *netdev)
+{
+	struct airoha_gdm_dev *dev = netdev_priv(netdev);
+
+	return dev->flags;
+}
+
+static int airoha_ethtool_get_sset_count(struct net_device *netdev, int sset)
+{
+	switch (sset) {
+	case ETH_SS_PRIV_FLAGS:
+		return AIROHA_PRIV_FLAGS_STR_LEN;
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+static void airoha_ethtool_get_strings(struct net_device *netdev,
+				       u32 stringset, u8 *data)
+{
+	int i;
+
+	switch (stringset) {
+	case ETH_SS_PRIV_FLAGS:
+		for (i = 0; i < AIROHA_PRIV_FLAGS_STR_LEN; i++)
+			ethtool_puts(&data, airoha_eth_priv_flags[i].name);
+		break;
+	default:
+		break;
+	}
+}
+
 static int airoha_qdma_set_chan_tx_sched(struct airoha_gdm_port *port,
 					 int channel, enum tx_sched_mode mode,
 					 const u16 *weights, u8 n_weights)
@@ -2864,6 +3012,10 @@ static const struct ethtool_ops airoha_e
 	.get_eth_mac_stats      = airoha_ethtool_get_mac_stats,
 	.get_rmon_stats		= airoha_ethtool_get_rmon_stats,
 	.get_link		= ethtool_op_get_link,
+	.set_priv_flags		= airoha_ethtool_set_priv_flags,
+	.get_priv_flags		= airoha_ethtool_get_priv_flags,
+	.get_sset_count		= airoha_ethtool_get_sset_count,
+	.get_strings		= airoha_ethtool_get_strings,
 };
 
 #if defined(CONFIG_PCS_AIROHA)
--- a/drivers/net/ethernet/airoha/airoha_eth.h
+++ b/drivers/net/ethernet/airoha/airoha_eth.h
@@ -532,6 +532,10 @@ struct airoha_qdma {
 	struct airoha_queue q_rx[AIROHA_NUM_RX_RING];
 };
 
+enum airoha_priv_flags {
+	PRIV_FLAG_WAN = BIT(0),
+};
+
 struct airoha_gdm_dev {
 	struct airoha_gdm_port *port;
 	struct net_device *dev;
@@ -542,6 +546,7 @@ struct airoha_gdm_dev {
 	struct phylink_pcs *pcs;
 #endif
 
+	u32 flags;
 	int nbq;
 };
 
@@ -642,15 +647,37 @@ u32 airoha_rmw(void __iomem *base, u32 o
 #define airoha_qdma_clear(qdma, offset, val)			\
 	airoha_rmw((qdma)->regs, (offset), (val), 0)
 
+static inline struct airoha_gdm_dev *
+airhoa_get_wan_gdm_dev(struct airoha_eth *eth)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(eth->ports); i++) {
+		struct airoha_gdm_port *port = eth->ports[i];
+		int j;
+
+		if (!port)
+			continue;
+
+		for (j = 0; j < ARRAY_SIZE(port->devs); j++) {
+			struct airoha_gdm_dev *dev = port->devs[j];
+
+			if (!dev)
+				continue;
+
+			if (dev->flags & PRIV_FLAG_WAN)
+				return dev;
+		}
+	}
+
+	return NULL;
+}
+
 static inline bool airhoa_is_lan_gdm_dev(struct airoha_gdm_dev *dev)
 {
 	struct airoha_gdm_port *port = dev->port;
 
-	/* GDM1 port on EN7581 SoC is connected to the lan dsa switch.
-	 * GDM{2,3,4} can be used as wan port connected to an external
-	 * phy module.
-	 */
-	return port->id == 1;
+	return airhoa_get_wan_gdm_dev(port->qdma->eth) != dev;
 }
 
 static inline bool airoha_is_7581(struct airoha_eth *eth)
--- a/drivers/net/ethernet/airoha/airoha_regs.h
+++ b/drivers/net/ethernet/airoha/airoha_regs.h
@@ -388,10 +388,8 @@
 #define SP_CPORT_MASK(_n)		GENMASK(3 + ((_n) << 2), ((_n) << 2))
 
 #define REG_SRC_PORT_FC_MAP6		0x2298
-#define FC_ID_OF_SRC_PORT27_MASK	GENMASK(28, 24)
-#define FC_ID_OF_SRC_PORT26_MASK	GENMASK(20, 16)
-#define FC_ID_OF_SRC_PORT25_MASK	GENMASK(12, 8)
-#define FC_ID_OF_SRC_PORT24_MASK	GENMASK(4, 0)
+#define FC_ID_OF_SRC_PORT_MASK(_n)	GENMASK(4 + ((_n) << 3), ((_n) << 3))
+#define FC_MAP6_DEF_VALUE		0x1b1a1918
 
 #define REG_CDM5_RX_OQ1_DROP_CNT	0x29d4
 
