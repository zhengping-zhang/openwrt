From 71a09b4c2e1d075fce9c0ae09e044dbde36bffba Mon Sep 17 00:00:00 2001
Message-ID: <71a09b4c2e1d075fce9c0ae09e044dbde36bffba.1765628489.git.lorenzo@kernel.org>
In-Reply-To: <533ca4c0e73e768cd82fe76fb30f814043f1f718.1765628489.git.lorenzo@kernel.org>
References: <533ca4c0e73e768cd82fe76fb30f814043f1f718.1765628489.git.lorenzo@kernel.org>
From: Lorenzo Bianconi <lorenzo@kernel.org>
Date: Sat, 13 Dec 2025 09:45:09 +0100
Subject: [nf-next 11/11] net: airoha: Add ethtool priv_flags callbacks

Introduce ethtool priv_flags callbacks in order to allow the user to
select if the configured device will be used as hw lan or wan.

Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
---
 drivers/net/ethernet/airoha/airoha_eth.c | 66 ++++++++++++++++++++++--
 drivers/net/ethernet/airoha/airoha_eth.h | 31 +++++++++--
 2 files changed, 88 insertions(+), 9 deletions(-)

--- a/drivers/net/ethernet/airoha/airoha_eth.c
+++ b/drivers/net/ethernet/airoha/airoha_eth.c
@@ -1631,6 +1631,11 @@ static int airoha_dev_open(struct net_de
 	struct airoha_qdma *qdma = port->qdma;
 	u32 pse_port = FE_PSE_PORT_PPE1;
 
+	if (port->id == AIROHA_GDM2_IDX && airhoa_is_lan_gdm_dev(dev)) {
+		/* GDM2 cab be used just as wan */
+		return -EBUSY;
+	}
+
 #if defined(CONFIG_PCS_AIROHA)
 	if (airhoa_is_phy_external(port)) {
 		err = phylink_of_phy_connect(dev->phylink,
@@ -1741,11 +1746,8 @@ static int airhoha_enable_gdm2_loopback(
 	u32 val, pse_port, chan;
 	int src_port;
 
-	/* Forward the traffic to the proper GDM port */
-	pse_port = port->id == AIROHA_GDM3_IDX ? FE_PSE_PORT_GDM3
-					       : FE_PSE_PORT_GDM4;
 	airoha_set_gdm_port_fwd_cfg(eth, REG_GDM_FWD_CFG(AIROHA_GDM2_IDX),
-				    pse_port);
+				    FE_PSE_PORT_DROP);
 	airoha_fe_clear(eth, REG_GDM_FWD_CFG(AIROHA_GDM2_IDX),
 			GDM_STRIP_CRC_MASK);
 
@@ -1763,6 +1765,11 @@ static int airhoha_enable_gdm2_loopback(
 		      GDM_SHORT_LEN_MASK | GDM_LONG_LEN_MASK,
 		      FIELD_PREP(GDM_SHORT_LEN_MASK, 60) |
 		      FIELD_PREP(GDM_LONG_LEN_MASK, AIROHA_MAX_MTU));
+	/* Forward the traffic to the proper GDM port */
+	pse_port = port->id == AIROHA_GDM3_IDX ? FE_PSE_PORT_GDM3
+					       : FE_PSE_PORT_GDM4;
+	airoha_set_gdm_port_fwd_cfg(eth, REG_GDM_FWD_CFG(AIROHA_GDM2_IDX),
+				    pse_port);
 
 	/* Disable VIP and IFC for GDM2 */
 	airoha_fe_clear(eth, REG_FE_VIP_PORT_EN, BIT(AIROHA_GDM2_IDX));
@@ -1791,6 +1798,59 @@ static int airhoha_enable_gdm2_loopback(
 	return 0;
 }
 
+static void airhoha_disable_gdm2_loopback(struct airoha_gdm_dev *dev)
+{
+	struct airoha_gdm_port *port = dev->port;
+	struct airoha_eth *eth = port->qdma->eth;
+	u32 pse_port, len;
+
+	airoha_set_gdm_port_fwd_cfg(eth, REG_GDM_FWD_CFG(AIROHA_GDM2_IDX),
+				    FE_PSE_PORT_DROP);
+	airoha_fe_clear(eth, REG_GDM_LPBK_CFG(AIROHA_GDM2_IDX),
+			LPBK_CHAN_MASK | LPBK_MODE_MASK | LPBK_EN_MASK);
+	pse_port = airoha_ppe_is_enabled(eth, 1) ? FE_PSE_PORT_PPE2
+						 : FE_PSE_PORT_PPE1;
+	airoha_set_gdm_port_fwd_cfg(eth, REG_GDM_FWD_CFG(AIROHA_GDM2_IDX),
+				    pse_port);
+
+	len = ETH_HLEN + dev->dev->mtu + ETH_FCS_LEN;
+	airoha_fe_rmw(eth, REG_GDM_LEN_CFG(AIROHA_GDM2_IDX),
+		      GDM_LONG_LEN_MASK, FIELD_PREP(GDM_LONG_LEN_MASK, len));
+
+	airoha_fe_rmw(eth, REG_FE_WAN_PORT, WAN0_MASK,
+		      FIELD_PREP(WAN0_MASK, AIROHA_GDM2_IDX));
+
+	airoha_fe_wr(eth, REG_SRC_PORT_FC_MAP6, FC_MAP6_DEF_VALUE);
+}
+
+static struct airoha_gdm_dev *
+airhoa_get_wan_gdm_dev(struct airoha_eth *eth)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(eth->ports); i++) {
+		struct airoha_gdm_port *port = eth->ports[i];
+		int j;
+
+		if (!port)
+			continue;
+
+		for (j = 0; j < ARRAY_SIZE(port->devs); j++) {
+			struct airoha_gdm_dev *dev = port->devs[j];
+
+			if (!dev)
+				continue;
+
+			if (airhoa_is_lan_gdm_dev(dev))
+				continue;
+
+			return dev;
+		}
+	}
+
+	return NULL;
+}
+
 static int airoha_dev_init(struct net_device *netdev)
 {
 	struct airoha_gdm_dev *dev = netdev_priv(netdev);
@@ -1798,24 +1858,28 @@ static int airoha_dev_init(struct net_de
 	struct airoha_eth *eth = port->qdma->eth;
 	int i;
 
-	airoha_set_macaddr(dev, netdev->dev_addr);
-
 	switch (port->id) {
+	case AIROHA_GDM2_IDX:
+		/* GDM2 is always used as wan */
+		dev->flags |= PRIV_FLAG_WAN;
+		break;
 	case AIROHA_GDM3_IDX:
 	case AIROHA_GDM4_IDX:
-		/* If GDM2 is active we can't enable loopback */
-		if (!eth->ports[1]) {
+		if (!eth->ports[1] && !airhoa_get_wan_gdm_dev(eth)) {
 			int err;
 
 			err = airhoha_enable_gdm2_loopback(dev);
 			if (err)
 				return err;
+
+			dev->flags |= PRIV_FLAG_WAN;
 		}
 		break;
 	default:
 		break;
 	}
 
+	airoha_set_macaddr(dev, netdev->dev_addr);
 	for (i = 0; i < eth->soc->num_ppe; i++)
 		airoha_ppe_set_def_cport(port, i);
 
@@ -2080,6 +2144,74 @@ error:
 	return NETDEV_TX_OK;
 }
 
+struct airoha_ethool_priv_flags {
+	char name[ETH_GSTRING_LEN];
+	int (*handler)(struct net_device *netdev, u32 flags);
+};
+
+static int airoha_dev_set_wan_flag(struct net_device *netdev, u32 flags)
+{
+	struct airoha_gdm_dev *dev = netdev_priv(netdev);
+	struct airoha_gdm_port *port = dev->port;
+	struct airoha_eth *eth = port->qdma->eth;
+
+	if (!((dev->flags ^ flags) & PRIV_FLAG_WAN))
+		return 0;
+
+	if (flags & PRIV_FLAG_WAN) {
+		struct airoha_gdm_dev *wan_dev;
+
+		/* Verify the wan device is not already configured */
+		wan_dev = airhoa_get_wan_gdm_dev(eth);
+		if (wan_dev && wan_dev != dev)
+			return -EBUSY;
+
+		switch (port->id) {
+		case AIROHA_GDM2_IDX:
+			airhoha_disable_gdm2_loopback(dev);
+			break;
+		case AIROHA_GDM3_IDX:
+		case AIROHA_GDM4_IDX: {
+			int err;
+
+			err = airhoha_enable_gdm2_loopback(dev);
+			if (err)
+				return err;
+			break;
+		}
+		default:
+			return -EOPNOTSUPP;
+		}
+
+		dev->flags |= PRIV_FLAG_WAN;
+		airoha_set_macaddr(dev, netdev->dev_addr);
+	} else {
+		switch (port->id) {
+		case AIROHA_GDM2_IDX:
+			if (netif_running(netdev)) {
+				/* GDM2 cab be used just as wan */
+				return -EBUSY;
+			}
+			break;
+		case AIROHA_GDM3_IDX:
+		case AIROHA_GDM4_IDX:
+			airoha_fe_wr(eth, REG_SRC_PORT_FC_MAP6,
+				     FC_MAP6_DEF_VALUE);
+			break;
+		default:
+			break;
+		}
+		dev->flags &= ~PRIV_FLAG_WAN;
+	}
+
+	return 0;
+}
+
+static const struct airoha_ethool_priv_flags airoha_eth_priv_flags[] = {
+	{ "wan", airoha_dev_set_wan_flag },
+};
+#define AIROHA_PRIV_FLAGS_STR_LEN	ARRAY_SIZE(airoha_eth_priv_flags)
+
 static void airoha_ethtool_get_drvinfo(struct net_device *netdev,
 				       struct ethtool_drvinfo *info)
 {
@@ -2089,6 +2221,7 @@ static void airoha_ethtool_get_drvinfo(s
 
 	strscpy(info->driver, eth->dev->driver->name, sizeof(info->driver));
 	strscpy(info->bus_info, dev_name(eth->dev), sizeof(info->bus_info));
+	info->n_priv_flags = AIROHA_PRIV_FLAGS_STR_LEN;
 }
 
 static void airoha_ethtool_get_mac_stats(struct net_device *netdev,
@@ -2153,6 +2286,56 @@ airoha_ethtool_get_rmon_stats(struct net
 	} while (u64_stats_fetch_retry(&port->stats.syncp, start));
 }
 
+static int airoha_ethtool_set_priv_flags(struct net_device *netdev, u32 flags)
+{
+	int i;
+
+	for (i = 0; i < AIROHA_PRIV_FLAGS_STR_LEN; i++) {
+		int err;
+
+		if (!airoha_eth_priv_flags[i].handler)
+			continue;
+
+		err = airoha_eth_priv_flags[i].handler(netdev, flags);
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
+
+static u32 airoha_ethtool_get_priv_flags(struct net_device *netdev)
+{
+	struct airoha_gdm_dev *dev = netdev_priv(netdev);
+
+	return dev->flags;
+}
+
+static int airoha_ethtool_get_sset_count(struct net_device *netdev, int sset)
+{
+	switch (sset) {
+	case ETH_SS_PRIV_FLAGS:
+		return AIROHA_PRIV_FLAGS_STR_LEN;
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+static void airoha_ethtool_get_strings(struct net_device *netdev,
+				       u32 stringset, u8 *data)
+{
+	int i;
+
+	switch (stringset) {
+	case ETH_SS_PRIV_FLAGS:
+		for (i = 0; i < AIROHA_PRIV_FLAGS_STR_LEN; i++)
+			ethtool_puts(&data, airoha_eth_priv_flags[i].name);
+		break;
+	default:
+		break;
+	}
+}
+
 static int airoha_qdma_set_chan_tx_sched(struct airoha_gdm_port *port,
 					 int channel, enum tx_sched_mode mode,
 					 const u16 *weights, u8 n_weights)
@@ -2861,6 +3044,10 @@ static const struct ethtool_ops airoha_e
 	.get_eth_mac_stats      = airoha_ethtool_get_mac_stats,
 	.get_rmon_stats		= airoha_ethtool_get_rmon_stats,
 	.get_link		= ethtool_op_get_link,
+	.set_priv_flags		= airoha_ethtool_set_priv_flags,
+	.get_priv_flags		= airoha_ethtool_get_priv_flags,
+	.get_sset_count		= airoha_ethtool_get_sset_count,
+	.get_strings		= airoha_ethtool_get_strings,
 };
 
 #if defined(CONFIG_PCS_AIROHA)
--- a/drivers/net/ethernet/airoha/airoha_eth.h
+++ b/drivers/net/ethernet/airoha/airoha_eth.h
@@ -532,6 +532,10 @@ struct airoha_qdma {
 	struct airoha_queue q_rx[AIROHA_NUM_RX_RING];
 };
 
+enum airoha_priv_flags {
+	PRIV_FLAG_WAN = BIT(0),
+};
+
 struct airoha_gdm_dev {
 	struct airoha_gdm_port *port;
 	struct net_device *dev;
@@ -542,6 +546,7 @@ struct airoha_gdm_dev {
 	struct phylink_pcs *pcs;
 #endif
 
+	u32 flags;
 	int nbq;
 };
 
@@ -644,13 +649,7 @@ u32 airoha_rmw(void __iomem *base, u32 o
 
 static inline bool airhoa_is_lan_gdm_dev(struct airoha_gdm_dev *dev)
 {
-	struct airoha_gdm_port *port = dev->port;
-
-	/* GDM1 port on EN7581 SoC is connected to the lan dsa switch.
-	 * GDM{2,3,4} can be used as wan port connected to an external
-	 * phy module.
-	 */
-	return port->id == 1;
+	return !(dev->flags & PRIV_FLAG_WAN);
 }
 
 static inline bool airoha_is_7581(struct airoha_eth *eth)
--- a/drivers/net/ethernet/airoha/airoha_regs.h
+++ b/drivers/net/ethernet/airoha/airoha_regs.h
@@ -388,6 +388,7 @@
 
 #define REG_SRC_PORT_FC_MAP6		0x2298
 #define FC_ID_OF_SRC_PORT_MASK(_n)	GENMASK(4 + ((_n) << 3), ((_n) << 3))
+#define FC_MAP6_DEF_VALUE		0x1b1a1918
 
 #define REG_CDM5_RX_OQ1_DROP_CNT	0x29d4
 
